#include <iostream>
#include <boost/algorithm/string.hpp>

#include "Space_Functions.h"

int count_digits(const std::string& s)
{
	int ret_val;
	ret_val = std::count_if(s.begin(), s.end(),[](unsigned char c){ return std::isdigit(c); } );
	if (ret_val > 5)
	{
		ret_val = 0;
	}
	return ret_val;
}

int Build_Near_By(int y, int x, int Player, std::vector<std::vector<char> > MAP)
{
	char HQ;
	char Workshop;
	int ret_val = 0;
	if (Player == 1)
	{
		HQ = 'H';
		Workshop = 'W';
	}
	else
	{
		HQ = 'h';
		Workshop = 'w';
	}
	int size = MAP[0].size() - 1;
	if (x == 0 && y == 0)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (x == 0 && y == size)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (x == size && y == 0)
	{
		if ( MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (x == size && y == size)
	{
		if ( MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (x == 0)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (x == size)
	{
		if ( MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (y == 0)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else if (y == size)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	else // x > 0 && x < size && y > 0 && y < size
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop)
		{
			ret_val = 1; 
		}
	}
	return ret_val;
}

int Workshop_Near_By(int y, int x, int Player, std::vector<std::vector<char> > MAP)
{
	char HQ;
	char Workshop;
	char Transport;
	char Fighter;
	int ret_val = 0;
	if (Player == 1)
	{
		HQ = 'H';
		Workshop = 'W';
		Transport = 'T';
		Fighter = 'F';
	}
	else
	{
		HQ = 'h';
		Workshop = 'w';
		Transport = 't';
		Fighter = 'f';
	}
	int size = MAP[0].size() - 1;
	if (x == 0 && y == 0)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x+1][y] == Transport 
			|| MAP[x+1][y] == Fighter
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop  
			|| MAP[x][y+1] == Transport 
			|| MAP[x][y+1] == Fighter )
		{
			ret_val = 1; 
		}
	}
	else if (x == 0 && y == size)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop
			|| MAP[x+1][y] == Transport 
			|| MAP[x+1][y] == Fighter 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop 
			|| MAP[x][y-1] == Transport 
			|| MAP[x][y-1] == Fighter )
		{
			ret_val = 1; 
		}
	}
	else if (x == size && y == 0)
	{
		if ( MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x-1][y] == Transport 
			|| MAP[x-1][y] == Fighter 
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y+1] == Transport 
			|| MAP[x][y+1] == Fighter )
		{
			ret_val = 1; 
		}
	}
	else if (x == size && y == size)
	{
		if ( MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop
			|| MAP[x-1][y] == Transport 
			|| MAP[x-1][y] == Fighter 
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop
			|| MAP[x][y-1] == Transport 
			|| MAP[x][y-1] == Fighter )
		{
			ret_val = 1; 
		}
	}
	else if (x == 0)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop
			|| MAP[x+1][y] == Transport 
			|| MAP[x+1][y] == Fighter
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y+1] == Transport 
			|| MAP[x][y+1] == Fighter
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop
			|| MAP[x][y-1] == Transport 
			|| MAP[x][y-1] == Fighter)
		{
			ret_val = 1; 
		}
	}
	else if (x == size)
	{
		if ( MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x-1][y] == Transport 
			|| MAP[x-1][y] == Fighter
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y+1] == Transport 
			|| MAP[x][y+1] == Fighter
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop
			|| MAP[x][y-1] == Transport 
			|| MAP[x][y-1] == Fighter)
		{
			ret_val = 1; 
		}
	}
	else if (y == 0)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x+1][y] == Transport
			|| MAP[x+1][y] == Fighter 
			|| MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x-1][y] == Transport 
			|| MAP[x-1][y] == Fighter
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop
			|| MAP[x][y+1] == Transport 
			|| MAP[x][y+1] == Fighter)
		{
			ret_val = 1; 
		}
	}
	else if (y == size)
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x+1][y] == Transport 
			|| MAP[x+1][y] == Fighter 
			|| MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x-1][y] == Transport 
			|| MAP[x-1][y] == Fighter
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop
			|| MAP[x][y-1] == Transport 
			|| MAP[x][y-1] == Fighter)
		{
			ret_val = 1; 
		}
	}
	else // x > 0 && x < size && y > 0 && y < size
	{
		if ( MAP[x+1][y] == HQ 
			|| MAP[x+1][y] == Workshop 
			|| MAP[x+1][y] == Transport 
			|| MAP[x+1][y] == Fighter
			|| MAP[x-1][y] == HQ 
			|| MAP[x-1][y] == Workshop 
			|| MAP[x-1][y] == Transport 
			|| MAP[x-1][y] == Fighter
			|| MAP[x][y+1] == HQ 
			|| MAP[x][y+1] == Workshop 
			|| MAP[x][y+1] == Transport 
			|| MAP[x][y+1] == Fighter
			|| MAP[x][y-1] == HQ 
			|| MAP[x][y-1] == Workshop
			|| MAP[x][y-1] == Transport 
			|| MAP[x][y-1] == Fighter)
		{
			ret_val = 1; 
		}
	}
	return ret_val;
}


int COLISION_DETECTOR(int x, int y, std::vector<Mine_Class> Mines, std::vector<Asteroid_Class> Asteroids, std::vector<Ship_Class> Ships, int Ship_ID, char* Obj_Type)
{
	int ret_val = -1;
	char Type = '.';
	for (int i = 0; i < Mines.size(); i++)
	{
		if (x == Mines[i].x && y == Mines[i].y)
		{
			Type = 'M';
			ret_val = i;
		}
	}

	for (int i = 0; i < Asteroids.size(); i++)
	{
		if (x == Asteroids[i].x && y == Asteroids[i].y)
		{
			Type = 'A';
			ret_val = i;
		}
	}

	for (int i = 0; i < Ships.size(); i++)
	{
		if (x == Ships[i].x && y == Ships[i].y && Ships[i].ID != Ship_ID)
		{
			Type = 'S';
			ret_val = i;
		}
	}
	std::cout << "COLISION DETECTOR DETECT " << Type << " ID " << Ships[ret_val].ID << std::endl;
	*Obj_Type = Type;
	return ret_val;

}


void Perform_Actions(Output_type Output_Player, std::vector<Mine_Class>* Mines, std::vector<Asteroid_Class>* Asteroids, std::vector<Ship_Class>* Ships, std::vector<std::vector<char> >* MAP, int Player)
{
	int MAP_SIZE = MAP[0].size();
	for (int i = 0; i < Output_Player.Commands_OUT.size(); i++)
	{
		std::string message = Output_Player.Commands_OUT[i];
		std::cout << message << std::endl;
		std::vector<std::string> split;
		boost::split(split, message, boost::is_any_of(" ") );
		if (split.size() > 0)
		{
			if (split[0] == "BUILD")
			{
				if ( count_digits(split[1]) && count_digits(split[2]) && count_digits(split[3]) && count_digits(split[4]) )
				{
					int Build_x = std::stoi(split[1]);
					int Build_y = std::stoi(split[2]);
					int Build_Type = std::stoi(split[3]);
					int Build_Rotation = std::stoi(split[4]);
					if ( (Build_x >= 0 && Build_x < MAP_SIZE) && (Build_y >= 0 && Build_y < MAP_SIZE) && (Build_Type == 1 || Build_Type == 2) && (Build_Rotation > 0 && Build_Rotation < 5) ) 
					{
						if ( (Build_Type == 1 && *Ships[Player -1].Storage >= 10) || (Build_Type == 2 && *Ships[Player -1].Storage >= 20))
						{
							if (MAP[Build_y][Build_x] == '.' && Build_Near_By(Build_x,Build_y, Player, MAP) )
							{
								Ship_Class Ship = Ship_Class(Build_Type, Player, Build_x, Build_y, Build_Rotation);
								*Ships.push_back(Ship);
								char res;
								if (Player == 1)
								{
									switch (Build_Type)
									{
										case 0:
											res = 'H';
											break;
										case 1:
											res = 'F';
											*Ships[Player -1].Storage -= 10;
											break;
										case 2:
											res = 'T';
											*Ships[Player -1].Storage -= 20;
											break;
									}
									MAP[Build_y][Build_x] = res;
								}
								if (Player == 2)
								{
									switch (Build_Type)
									{
										case 0:
											res = 'h';
											break;
										case 1:
											res = 'f';
											*Ships[Player -1].Storage -= 10;
											break;
										case 2:
											res = 't';
											*Ships[Player -1].Storage -= 20;
											break;
									}
									MAP[Build_y][Build_x] = res;
								}
							}
							else
							{
								std::cout << "YOU CAN BUILD NEW SHIP OLNY NEAR BY HQ OR WORKSHOP ON EMPTY SPACE" << std::endl;
							}
						}
						else
						{
							std::cout << "NOT ENOUGHT MATERIALS TO BUILD NEW SHIP" << std::endl;
						}
					}
					else
					{
						std::cout << "BUILD COORDINATES, SHIP TYPE OR ROTATION ARE INCORRECT" << std::endl;
					}
				}
				else
				{
					std::cout << "WRONG BUILD COMMAND" << std::endl;
				}
			}
			if (split[0] == "MOVE")
			{
				if ( count_digits(split[1]) )
				{
					int Move_ID = std::stoi(split[1]);
					int Move_iterator = -1;
					for (int i = 0; i < *Ships.size(); i++)
					{
						if (Move_ID == *Ships[i].ID &&  *Ships[i].Player == Player)
						{
							Move_iterator = i;
						}
					}
					if (( Move_ID != 0 && Move_ID != 1) && Move_iterator != -1)
					{
						if ( *Ships[Move_iterator].Speed > 0)
						{
							if (E_OK == *Ships[Move_iterator].MOVE() )
							{
								*Ships[Move_iterator].Speed--;
								int p_x = *Ships[Move_iterator].x;
								int p_y = *Ships[Move_iterator].y;
								if (MAP[p_y][p_x] != '.')
								{
									char Type;
									int Colision_ID = COLISION_DETECTOR(p_x, p_y, *Mines, *Asteroids, *Ships, Move_ID, &Type);
									if (Type == 'M')
									{
										int HP_Mine = *Mines[Colision_ID].HP - *Ships[Move_iterator].HP;
										int HP_Ship = *Ships[Move_iterator].HP - *Mines[Colision_ID].HP;
										*Mines[Colision_ID].HP = HP_Mine;
										*Ships[Move_iterator].HP = HP_Ship;
									}
									if (Type == 'A')
									{
										int HP_Asteroid = *Asteroids[Colision_ID].HP - *Ships[Move_iterator].HP;
										int HP_Ship = *Ships[Move_iterator].HP - *Asteroids[Colision_ID].HP;
										*Asteroids[Colision_ID].HP = HP_Asteroid;
										*Ships[Move_iterator].HP = HP_Ship;
									}
									if (Type == 'S')
									{
										int HP_Ship_Col = *Ships[Colision_ID].HP - *Ships[Move_iterator].HP;
										int HP_Ship_Mov = *Ships[Move_iterator].HP - *Ships[Colision_ID].HP;
										*Ships[Colision_ID].HP = HP_Ship_Col;
										*Ships[Move_iterator].HP = HP_Ship_Mov;
									}
									
								}
									
							}
							else
							{
								std::cout << "THIS SHIP CAN'T MOVE AT THIS DIRECTION" << std::endl;
							}
						}
						else
						{
							std::cout << "THIS SHIP HAVE NO POWER TO PERFORM ANY ACTION THIS TURN" << std::endl;
						}
					}
					else
					{
						std::cout << "INAVLID SHIP ID" << std::endl;
					}
				}
					else
				{
					std::cout << "WRONG MOVE COMMAND" << std::endl;
				}
			}
			if (split[0] == "ROTATE")
			{
				if (count_digits(split[1]) && (split[2] == "L" ||  split[2] == "R") )
				{
					int Rotate_ID = std::stoi(split[1]);
					char Rotate_Direction = split[2][0];
					int Rotate_iterator = -1;
					for (int i = 0; i < *Ships.size(); i++)
					{
						if (Rotate_ID == *Ships[i].ID &&  *Ships[i].Player == Player)
						{
							Rotate_iterator = i;
						}
					}
					if (Rotate_iterator != -1 )
					{
						if ( *Ships[Rotate_iterator].Speed > 0 )
						{
								if (E_OK == *Ships[Rotate_iterator].ROTATE(Rotate_Direction) )
							{
								*Ships[Rotate_iterator].Speed--;
							}
						}
						else
						{
							std::cout << "THIS SHIP HAVE NO POWER TO PERFORM ANY ACTION THIS TURN" << std::endl;
						}
					}
					else
					{
						std::cout << "INAVLID SHIP ID" << std::endl;
					}
				}
				else
				{
					std::cout << "WRONG ROTATE COMMAND" << std::endl;
				}
			}
			if (split[0] == "SHOOT")
			{
				if ( count_digits(split[1]) )
				{
					int Shoot_ID = std::stoi(split[1]);
					int Shoot_iterator = -1;
					for (int i = 0; i < *Ships.size(); i++)
					{
						if (Shoot_ID == *Ships[i].ID &&  *Ships[i].Player == Player)
						{
							Shoot_iterator = i;
						}
					}
					if (Shoot_iterator != -1)
					{
						if ( *Ships[Shoot_iterator].Speed > 0)
						{
							*Ships[Shoot_iterator].Speed--;
							for (int i = 0; i < *Ships[Shoot_iterator].Range; i++)
							{
								int p_x = *Ships[Shoot_iterator].x;
								int p_y = *Ships[Shoot_iterator].y;
								if (*Ships[Shoot_iterator].Rotation == 1 && p_x < MAP_SIZE -i -1)
								{
									if (MAP[p_y][p_x +i +1] != '.')
									{
										char Type;
										int Colision_ID = COLISION_DETECTOR(p_x +i +1, p_y, *Mines, *Asteroids, *Ships, Shoot_ID, &Type);
										if (Type == 'M')
										{
											*Mines[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}	
										if (Type == 'A')
										{
											*Asteroids[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
										if (Type == 'S')
										{
											*Ships[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
									}
								}
								if (*Ships[Shoot_iterator].Rotation == 2 && p_x > i +1) 
								{
									if (MAP[p_y][p_x -i -1] != '.')
									{
										char Type;
										int Colision_ID = COLISION_DETECTOR(p_x -i -1, p_y, *Mines, *Asteroids, *Ships, Shoot_ID, &Type);
										if (Type == 'M')
										{
											*Mines[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}	
										if (Type == 'A')
										{
											*Asteroids[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
										if (Type == 'S')
										{
											*Ships[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
									}
								}
								if (*Ships[Shoot_iterator].Rotation == 3 && p_y < MAP_SIZE -i -1)
								{
									if (MAP[p_y +i +1][p_x] != '.')
									{
										char Type;
										int Colision_ID = COLISION_DETECTOR(p_x, p_y +i +1, *Mines, *Asteroids, *Ships, Shoot_ID, &Type);
										if (Type == 'M')
										{
											*Mines[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}	
										if (Type == 'A')
										{
											*Asteroids[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
										if (Type == 'S')
										{
											*Ships[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
									}
								}
								if (*Ships[Shoot_iterator].Rotation == 4 && p_y > i +1)
								{
									if (MAP[p_y -i -1][p_x] != '.')
									{
										char Type;
										int Colision_ID = COLISION_DETECTOR(p_x, p_y -i -1, *Mines, *Asteroids, *Ships, Shoot_ID, &Type);
										if (Type == 'M')
										{
											*Mines[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}	
										if (Type == 'A')
										{
											*Asteroids[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
										if (Type == 'S')
										{
											*Ships[Colision_ID].HP -= *Ships[Shoot_iterator].Damage;
										}
										std::cout << "Shoot " << Type << " ID " << Colision_ID << std::endl;
									}
								}
							}
						}
						else
						{
							std::cout << "THIS SHIP HAVE NO POWER TO PERFORM ANY ACTION THIS TURN" << std::endl;
						}
					}
					else
					{
						std::cout << "INAVLID SHIP ID" << std::endl;
					}
				}
				else
				{
					std::cout << "WRONG SHOOT COMMAND" << std::endl;
				}
			}
			if (split[0] == "WORKSHOP")
			{
				if ( count_digits(split[1]) && count_digits(split[2]) )
				{
					int Workshop_x = std::stoi(split[1]);
					int Workshop_y = std::stoi(split[2]);
					if ( (Workshop_x >= 0 && Workshop_x < MAP_SIZE) && (Workshop_y >= 0 && Workshop_y < MAP_SIZE) ) 
					{
						if ( *Ships[Player -1].Storage >= 25 )
						{
							if (MAP[Workshop_y][Workshop_x] == 'A' && Workshop_Near_By(Workshop_x, Workshop_y, Player, MAP) )
							{
								int Workshop_iterator;
								for (int i = 0; i < *Asteroids.size(); i++)
								{
									if (Workshop_x == *Asteroids[i].x && Workshop_y == *Asteroids[i].y )
									{
										Workshop_iterator = i;
									}
								}
								*Asteroids[Workshop_iterator].Workshop = Player;
								*Ships[Player -1].Storage -= 25;									
							}
							else
							{
								std::cout << "YOU CAN BUILD NEW WORKSHOP OLNY NEAR BY HQ, ANOTHER WORKSHOP OR ONE OF YOURS SHIPS ON ASTEROID" << std::endl;
							}
						}
						else
						{
							std::cout << "NOT ENOUGHT MATERIALS TO BUILD NEW WORKSHOP" << std::endl;
						}
					}
					else
					{
						std::cout << "BUILD COORDINATES ARE INCORRECT" << std::endl;
					}
				}
				else
				{
					std::cout << "WRONG WORKSHOP COMMAND" << std::endl;
				}
			}
			if (split[0] == "DIG")
			{
				if ( count_digits(split[1]) )
				{
					int Dig_ID = std::stoi(split[1]);
					int Dig_iterator = -1;
					for (int i = 0; i < *Ships.size(); i++)
					{
						if (Dig_ID == *Ships[i].ID &&  *Ships[i].Player == Player)
						{
							Dig_iterator = i;
						}
					}
					if (Dig_iterator != -1 && (Dig_ID != 0 && Dig_ID != 1) )
					{
						if ( *Ships[Dig_iterator].Speed > 0)
						{
							*Ships[Dig_iterator].Speed--;
							int p_x = *Ships[Dig_iterator].x;
							int p_y = *Ships[Dig_iterator].y;
							if (*Ships[Dig_iterator].Rotation == 1 && p_x < MAP_SIZE -1)
							{
								if (MAP[p_y][p_x +1] == 'M')
								{
									*Ships[Dig_iterator].Storage += 5;
									if (*Ships[Dig_iterator].Storage > *Ships[Dig_iterator].MAX_Storage)
									{
										*Ships[Dig_iterator].Storage = *Ships[Dig_iterator].MAX_Storage;
									}
								}
							}
							if (*Ships[Dig_iterator].Rotation == 2 && p_x > 1) 
							{
								if (MAP[p_y][p_x -1] == 'M')
								{
									*Ships[Dig_iterator].Storage += 5;
									if (*Ships[Dig_iterator].Storage > *Ships[Dig_iterator].MAX_Storage)
									{
										*Ships[Dig_iterator].Storage = *Ships[Dig_iterator].MAX_Storage;
									}
								}
							}
							if (*Ships[Dig_iterator].Rotation == 3 && p_y < MAP_SIZE -1)
							{
								if (MAP[p_y +1][p_x] == 'M')
								{
									*Ships[Dig_iterator].Storage += 5;
									if (*Ships[Dig_iterator].Storage > *Ships[Dig_iterator].MAX_Storage)
									{
										*Ships[Dig_iterator].Storage = *Ships[Dig_iterator].MAX_Storage;
									}
								}
							}
							if (*Ships[Dig_iterator].Rotation == 4 && p_y > i +1)
							{
								if (MAP[p_y -1][p_x] == 'M')
								{
									*Ships[Dig_iterator].Storage += 5;
									if (*Ships[Dig_iterator].Storage > *Ships[Dig_iterator].MAX_Storage)
									{
										*Ships[Dig_iterator].Storage = *Ships[Dig_iterator].MAX_Storage;
									}
								}
							}
						}
						else
						{
							std::cout << "THIS SHIP HAVE NO POWER TO PERFORM ANY ACTION THIS TURN" << std::endl;
						}
					}
					else
					{
						std::cout << "INAVLID SHIP ID" << std::endl;
					}
				}
				else
				{
					std::cout << "WRONG DIG COMMAND" << std::endl;
				}
			}
			if (split[0] == "END")
			{
				break;
			}
		}
	}
}
